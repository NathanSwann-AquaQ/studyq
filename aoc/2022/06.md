# Day 6: Tuning Trouble

The preparations are finally complete; you and the Elves leave camp on foot and begin to make your way toward the star fruit grove.

As you move through the dense undergrowth, one of the Elves gives you a handheld device. He says that it has many fancy features, but the most important one to set up right now is the communication system.


Advent of Code 2022 [Day 6](https://adventofcode.com/2022/day/6)

## Ingestion

```q
input:read0`:test/06.txt
```

## Part 1

Looking for the marker, we have two things to do:

1.  test a substring for no duplicate chars
1.  either generate all the substrings or crawl the string testing for a marker

### Testing for a marker

A simple way to test a substring for being a marker is `4=count distinct::`.
We can make this independent of the substring length, as `{count[x]=count distinct x}`, or refactor the two `count`s out as `{.[=](count')1 distinct\x}`. 

At which point we notice we can drop the `count`s and simply use Match: `{x~distinct x}`.

```q
q){4=count distinct x}each("abac";"abcd")
01b
q){x~distinct x}each("abac";"abcd")
01b
```

But as `count` is close to free, there is no significant efficiency gain.

```q
q)\ts:10000 {4=count distinct x}each("abac";"abcd")
10 1888
q)\ts:10000 {x~distinct x}each("abac";"abcd")
10 1584
```

### Finding substrings

One way is to generate indices for all the 4-char substrings.

```q
q)(til count[inp]-1)+\:til 4
0  1  2  3
1  2  3  4
2  3  4  5
3  4  5  6
..
q)inp (til count[inp]-1)+\:til 4
"mjqj"
"jqjp"
"qjpq"
"jpqm"
..
```

Or just dropping a char and applying `4#`.

```q
q)(1_)\[inp]
"mjqjpqmgbljsphdztnvjfqwrcgsmlb"
"jqjpqmgbljsphdztnvjfqwrcgsmlb"
"qjpqmgbljsphdztnvjfqwrcgsmlb"
"jpqmgbljsphdztnvjfqwrcgsmlb"
..
q)4#'(1_)\[inp]
"mjqj"
"jqjp"
"qjpq"
"jpqm"
..

Or apply `next` three times, and flip.

```q
q)3 next\inp
"mjqjpqmgbljsphdztnvjfqwrcgsmlb"
"jqjpqmgbljsphdztnvjfqwrcgsmlb "
"qjpqmgbljsphdztnvjfqwrcgsmlb  "
"jpqmgbljsphdztnvjfqwrcgsmlb   "
q)flip 3 next\inp
"mjqj"
"jqjp"
"qjpq"
"jpqm"
..
```

Or

```q
q){neg[y] sublist x,z}\[();4;inp]
,"m"
"mj"
"mjq"
"mjqj"
"jqjp"
..
```

It appears the third is the most efficient:

```q
q)\ts:10000 inp (til count[inp]-1)+\:til 4
49 4000
q)\ts:10000 (1_)\[inp]
52 2432
q)\ts:10000 flip 3 next\inp
25 1792
q)\ts:10000 {neg[y] sublist x,z}\[();4;inp]
254 2128
```


## Applying the test

We have a choice: 

1.  test all the substrings then look for the first hit
1.  test each substring in turn until we find a hit

```q
q)4+first where{x~distinct x}each flip 3 next\inp  /test all
7
q)4+first {x>count distinct y z}[4;inp](1+)/til 4
7
```

The second looks more efficient. It avoids many unnecessary tests when the marker occurs early in the string. 
But vector-hungry q sometimes makes ‘overcomputing’ faster.

```q
q)\ts:10000 4+first where{x~distinct x}each flip 3 next\inp
111 3680
q)\ts:10000 {x+first {x>count distinct y z}[x;y](1+)/til x}[4;inp]
28 3648
```

Not here: early termination of the source pays off.

## Part 2

As we have been wise enough to make the marker length an argument, we can easily adapt the search.

```q
q)4 14 {x+first {x>count distinct y z}[x;y](1+)/til x}\: inp
7 19
```

## Contributors

* Sean Ang
* András Dőtsch
* Tom Ferguson 
* Péter Györök
* Nick Psaris
* Cillian Reilly
* Nathan Swann
* Stephen Taylor
* Zsolt Venczel

